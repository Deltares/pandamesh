
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/preprocessing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_preprocessing.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_preprocessing.py:


Preprocessing
=============

Raw geospatial vector data is often not ready to use directly in mesh
generation:
    
* Polygon data often do not form a valid planar partition: polygons are
  overlapping, or neighboring polygons have small gaps between them.
* Polygon boundaries or linestring segments intersect each other.
* Points may be located on polygon boundaries or lines. Since floating point
  numbers are not exact, points seemingly located on a line are computationally
  just left or just right of the line and form an extremely thin triangle.
* Points may be located extremely close together, thereby generating tiny
  triangles.
  
Such problems either lead to a generated mesh with extremely small elements, or
worse, they lead to a crash of the meshing program. Pandamesh provides a
``Preprocessor`` class to assist with cleaning up some common faults. 

This example will illustrate some common problems and how to resolve them.

.. GENERATED FROM PYTHON SOURCE LINES 24-32

.. code-block:: Python

    import geopandas as gpd
    import matplotlib.pyplot as plt
    import numpy as np
    import shapely
    import shapely.geometry as sg

    import pandamesh as pm








.. GENERATED FROM PYTHON SOURCE LINES 33-41

Polygons
--------

When generating a mesh, we often have a general area which may be meshed
coarsely and an area of interest, which should be meshed more finely.
Generally, the fine inner zone is located within the coarse outer zone, but
this requires a hole in the outer zone that exactly matches up with the
exterior of the inner zone.

.. GENERATED FROM PYTHON SOURCE LINES 41-66

.. code-block:: Python


    outer = sg.Polygon(
        [
            [0.0, 0.0],
            [10.0, 0.0],
            [10.0, 10.0],
            [0.0, 10.0],
        ]
    )
    inner = sg.Polygon(
        [
            [5.0, 2.0],
            [8.0, 5.0],
            [5.0, 8.0],
            [2.0, 5.0],
        ]
    )

    gdf = gpd.GeoDataFrame(geometry=[outer, inner])
    gdf["cellsize"] = [2.0, 1.0]

    fig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(10, 5), sharex=True, sharey=True)
    gdf.iloc[[0]].plot(ax=ax0)
    gdf.iloc[[1]].plot(ax=ax1)




.. image-sg:: /examples/images/sphx_glr_preprocessing_001.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 67-69

In this case, we have two conflicting specified cell sizes in the inner
square. We can resolve this as follows:

.. GENERATED FROM PYTHON SOURCE LINES 69-76

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .unify_polygons()
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})








.. GENERATED FROM PYTHON SOURCE LINES 77-81

Note that the Preprocessor supports method chaining, allowing you to flexibly
execute a set of operations.

The resulting geodataframe's geometries are valid planar partition:

.. GENERATED FROM PYTHON SOURCE LINES 81-86

.. code-block:: Python


    fig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(10, 5), sharex=True, sharey=True)
    resolved.iloc[[0]].plot(ax=ax0)
    resolved.iloc[[1]].plot(ax=ax1)




.. image-sg:: /examples/images/sphx_glr_preprocessing_002.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 87-88

And we can use it directly to generate a mesh:

.. GENERATED FROM PYTHON SOURCE LINES 88-92

.. code-block:: Python


    vertices, faces = pm.TriangleMesher(resolved).generate()
    pm.plot(vertices, faces)




.. image-sg:: /examples/images/sphx_glr_preprocessing_003.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 93-95

Alternatively, multiple polygons with the same cell size specification might
be overlapping

.. GENERATED FROM PYTHON SOURCE LINES 95-103

.. code-block:: Python


    inner0 = shapely.affinity.translate(inner, xoff=-1.0)
    inner1 = shapely.affinity.translate(inner, xoff=1.0)
    gdf = gpd.GeoDataFrame(geometry=[outer, inner0, inner1])
    gdf["cellsize"] = [2.0, 1.0, 1.0]

    fig, ax = plt.subplots(figsize=(5, 5))
    gdf.plot(ax=ax, facecolor="none")



.. image-sg:: /examples/images/sphx_glr_preprocessing_004.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 104-105

These will also be resolved by ``.unify_polygons``.

.. GENERATED FROM PYTHON SOURCE LINES 105-118

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .unify_polygons()
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})

    vertices, faces = pm.TriangleMesher(resolved).generate()

    fig, ax = plt.subplots(figsize=(5, 5))
    pm.plot(vertices, faces, ax=ax)
    resolved.plot(ax=ax, facecolor="none", edgecolor="red")




.. image-sg:: /examples/images/sphx_glr_preprocessing_005.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_005.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 119-121

Note, however, that the internal boundaries of the inner polygons are forced
into the triangulation. We can rid of these by calling ``.merge_polygons``:

.. GENERATED FROM PYTHON SOURCE LINES 121-135

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .unify_polygons()
        .merge_polygons()
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})

    vertices, faces = pm.TriangleMesher(resolved).generate()

    fig, ax = plt.subplots(figsize=(5, 5))
    pm.plot(vertices, faces, ax=ax)
    resolved.plot(ax=ax, facecolor="none", edgecolor="red")




.. image-sg:: /examples/images/sphx_glr_preprocessing_006.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_006.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 136-138

An alternative problem is when polygons are touching, but do not actually
share vertices along the boundary.

.. GENERATED FROM PYTHON SOURCE LINES 138-162

.. code-block:: Python


    first = sg.Polygon(
        [
            [0.0, 0.0],
            [10.0, 0.0],
            [10.0, 10.0],
            [0.0, 10.0],
        ]
    )
    second = sg.Polygon(
        [
            [10.0, 2.0],
            [18.0, 2.0],
            [18.0, 8.0],
            [10.0, 8.0],
        ]
    )

    gdf = gpd.GeoDataFrame(geometry=[first, second])
    gdf["cellsize"] = [4.0, 2.0]

    vertices, faces = pm.GmshMesher(gdf).generate()
    pm.plot(vertices, faces)




.. image-sg:: /examples/images/sphx_glr_preprocessing_007.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_007.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 163-167

At x=10.0, the generated triangles are disconnected.

Calling ``.unify_polygons()`` ensures that the vertices of touching polygons
are inserted, such that the polygons share an edge.

.. GENERATED FROM PYTHON SOURCE LINES 167-181

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .unify_polygons()
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})

    vertices, faces = pm.TriangleMesher(resolved).generate()
    polygon0_coords = shapely.get_coordinates(resolved.geometry[0])

    fig, ax = plt.subplots(figsize=(5, 5))
    pm.plot(vertices, faces, ax=ax)
    ax.scatter(*polygon0_coords.T)




.. image-sg:: /examples/images/sphx_glr_preprocessing_008.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_008.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.collections.PathCollection object at 0x7f43be8196d0>



.. GENERATED FROM PYTHON SOURCE LINES 182-186

Lines
-----

Lines may only be only partially present, or present in holes:

.. GENERATED FROM PYTHON SOURCE LINES 186-220

.. code-block:: Python


    donut = sg.Polygon(
        [
            [0.0, 0.0],
            [10.0, 0.0],
            [10.0, 10.0],
            [0.0, 10.0],
        ],
        holes=[
            [
                [2.0, 5.0],
                [5.0, 8.0],
                [8.0, 5.0],
                [5.0, 2.0],
            ]
        ],
    )
    line0 = shapely.LineString(
        [
            [-2.0, 0.0],
            [12.0, 10.0],
        ]
    )
    line1 = shapely.LineString(
        [
            [5.5, 9.0],
            [9.0, 5.5],
        ]
    )

    gdf = gpd.GeoDataFrame(geometry=[donut, line0, line1])
    gdf["cellsize"] = [2.0, 1.0, 1.0]
    gdf.plot(edgecolor="k")




.. image-sg:: /examples/images/sphx_glr_preprocessing_009.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_009.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 221-222

A first step is to remove line segments that do not fall in any polygon:

.. GENERATED FROM PYTHON SOURCE LINES 222-230

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .clip_lines()
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})
    resolved.plot(edgecolor="k")




.. image-sg:: /examples/images/sphx_glr_preprocessing_010.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_010.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 231-234

However, this doesn't create suitable input for meshing. The ``GmshMesher``
appears to hang on this input, and Triangle generates a grid with very small
triangles:

.. GENERATED FROM PYTHON SOURCE LINES 234-238

.. code-block:: Python


    vertices, faces = pm.TriangleMesher(resolved).generate()
    pm.plot(vertices, faces)




.. image-sg:: /examples/images/sphx_glr_preprocessing_011.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_011.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 239-253

A better approach here is to ensure all intersections are present in all
linework:

* First we clip.
* Then we call ``unify_lines`` to ensure that the intersection of line0 and
  line1 at (7.625 6.875) is represented.
* Next we call ``unify_polygons``. This ensures the intersections of the lines
  with the poygon exterior is represented as well.
* The result of ``unify_polygons`` is that the line splits the polygon in two
  parts. These are merged back together with ``merge_polygons``.

If we plot the vertices of the resolved polygon, we see that the intersection
vertices have been inserted into the polygon boundaries, and that the tiny
triangles around the line intersection have disappeared:

.. GENERATED FROM PYTHON SOURCE LINES 253-270

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .clip_lines()
        .unify_lines()
        .unify_polygons()
        .merge_polygons()
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})

    vertices, faces = pm.GmshMesher(resolved).generate()
    polygon0_coords = shapely.get_coordinates(resolved.geometry[0])

    fig, ax = plt.subplots(figsize=(5, 5))
    pm.plot(vertices, faces, ax=ax)
    ax.scatter(*polygon0_coords.T)




.. image-sg:: /examples/images/sphx_glr_preprocessing_012.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_012.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.collections.PathCollection object at 0x7f43be659610>



.. GENERATED FROM PYTHON SOURCE LINES 271-274

In some cases, having line segments terminate exactly on polygon boundaries
still causes trouble. We may also ensure that lines are some distance removed
from any polygon boundary by providing a distance to ``clip_lines``:

.. GENERATED FROM PYTHON SOURCE LINES 274-290

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .unify_lines()
        .clip_lines(distance=0.5)
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})

    vertices, faces = pm.GmshMesher(resolved).generate()
    polygon0_coords = shapely.get_coordinates(resolved.geometry[0])

    fig, ax = plt.subplots(figsize=(5, 5))
    pm.plot(vertices, faces, ax=ax)
    resolved.plot(facecolor="none", edgecolor="red", ax=ax)
    ax.scatter(*polygon0_coords.T)




.. image-sg:: /examples/images/sphx_glr_preprocessing_013.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_013.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <matplotlib.collections.PathCollection object at 0x7f43be7f1d30>



.. GENERATED FROM PYTHON SOURCE LINES 291-293

Another pragmatic approach is to convert any line into interpolated points.
Points cannot intersect each other, which sidesteps a large number of problems.

.. GENERATED FROM PYTHON SOURCE LINES 293-307

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .interpolate_lines_to_points(distance=0.25)
        .clip_points()
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})

    vertices, faces = pm.GmshMesher(resolved).generate()

    fig, ax = plt.subplots(figsize=(5, 5))
    pm.plot(vertices, faces, ax=ax)
    resolved.plot(facecolor="none", edgecolor="red", ax=ax)




.. image-sg:: /examples/images/sphx_glr_preprocessing_014.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_014.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 308-315

Points
------

Note that the start and end points of the lines are still on, or very near
the polygon edges.

We can remove those points by providing a distance to ``clip_points``.

.. GENERATED FROM PYTHON SOURCE LINES 315-329

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .interpolate_lines_to_points(distance=0.25)
        .clip_points(distance=0.5)
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})

    vertices, faces = pm.GmshMesher(resolved).generate()

    fig, ax = plt.subplots(figsize=(5, 5))
    pm.plot(vertices, faces, ax=ax)
    resolved.plot(facecolor="none", edgecolor="red", ax=ax)




.. image-sg:: /examples/images/sphx_glr_preprocessing_015.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_015.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 330-332

A problem with points is that they may be very close together, thereby
generating very small triangles. Let's generate 200 random points to illustrate:

.. GENERATED FROM PYTHON SOURCE LINES 332-347

.. code-block:: Python


    rng = np.random.default_rng()
    points = gpd.points_from_xy(*rng.random((2, 200)) * 10.0)
    gdf = gpd.GeoDataFrame(geometry=np.concatenate([[donut], points]))
    gdf["cellsize"] = 2.0

    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .clip_points(distance=0.5)
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})

    vertices, faces = pm.GmshMesher(resolved).generate()
    pm.plot(vertices, faces)




.. image-sg:: /examples/images/sphx_glr_preprocessing_016.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_016.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 348-350

We can solve this by snapping points together that are located some distance
from each other:

.. GENERATED FROM PYTHON SOURCE LINES 350-361

.. code-block:: Python


    resolved = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .clip_points(distance=0.5)
        .snap_points(distance=0.5)
        .to_geodataframe()
    ).rename(columns={"values": "cellsize"})

    vertices, faces = pm.GmshMesher(resolved).generate()
    pm.plot(vertices, faces)




.. image-sg:: /examples/images/sphx_glr_preprocessing_017.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_017.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 362-375

Flexibility and composability
-----------------------------

The Preprocessor class in Pandamesh is designed with flexibility and
composability in mind through method chaining. By combining various
preprocessing steps in any order, you can address a wide range of geometric
issues. For instance, you might start by unifying polygons, then clip lines,
interpolate them to points, and finally snap those points together.

The steps required depend on the nature of geometrical input, and may require
experimenting with various methods. The intermediate output can be checked
and visualized at any moments, by calling ``to_geodataframe``. For example,
to check the intermediate result after clipping but prior to snapping:

.. GENERATED FROM PYTHON SOURCE LINES 375-384

.. code-block:: Python


    check = (
        pm.Preprocessor(geometry=gdf.geometry, values=gdf.cellsize)
        .clip_points(distance=0.5)
        .to_geodataframe()
    )

    check.plot(facecolor="none", edgecolor="red")




.. image-sg:: /examples/images/sphx_glr_preprocessing_018.png
   :alt: preprocessing
   :srcset: /examples/images/sphx_glr_preprocessing_018.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <Axes: >



.. GENERATED FROM PYTHON SOURCE LINES 385-390

This also makes it easy to apply the preprocessor in steps. Some steps may be
relatively costly, such as unifying a large number of detailed polygons. The
intermediate result can be stored as e.g. a GeoPackage. Then, in a separate
processing step, the intermediate result can be read again, and other
processing steps (such as filtering points) can be applied.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.394 seconds)


.. _sphx_glr_download_examples_preprocessing.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: preprocessing.ipynb <preprocessing.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: preprocessing.py <preprocessing.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: preprocessing.zip <preprocessing.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
